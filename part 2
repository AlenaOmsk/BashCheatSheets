Раскрытие скобок
В отличии от символов подстановки имен файлов, раскрытие скобок имееет исключительно текстовый характер. В частности, слова, образующиеся при раскрытии скобок, совсем не обязательно должны совпадать с именами существующих файлов. Имеются след. формы раскрытия скобок:
pre{X,Y[, Z...]}post - раскрывается до  preXpost, preYpost и т.д.
pre{start..end [incr]}post где start и end обозначают целые числа или одиночные буквы, а incr - целое число. Оболочка рисширяет эту конструкцию до полного диапозона в пределах от start до end, увеличиваю целое число incr, если оно указыватеся 
Постфиксные и префиксные тексты в обеих формах необязательны. В числовом выражении пределы start и end вместе или по отдельности могут предваряться одним или более начальным нулем.

В оболочке Bash управляющие последовательности символом распознаются и интерпритируются в след.контекстах (https://debianinstall.ru/upravlyayushhie-simvoly-linux/)
Символьная строка в форме $'...', заключаемая в одиночные кавычки
Аргументы, указываемые в командах echo -e и printf %b
Форматирующие строки, указываемые в команде printf


\а - все контексты - звонок (Bel в коде ASCII) звуковой или предупреждающий сигнал 
\b - все контексты - возврат на одну позицию
\c - команды echo -e и printf %b - подавить завершающий знак новой строки (например в команде echo -n не выводить ни один из последующих символов)
\cX - строка в форме  $'...'- управляющий символ х
\e - все контексты - переход
\E - все контексты - переход
\f - все контексты - перевод страницы
\n - все контексты - перевод строки
\r - все контексты - возврат каретки
\t - все контексты - табуляция
\uHHH - все контексты - символ HHH в Юникоде 
\uHHHHHHHH - все контексты - символ HHHHHHHH в Юникоде 
\v - все контексты - вертикальная табуляция
\xHH - все контексты - шестнадцатеричное значение  HH
\nnn - строка в форме  $'...', команда printf  - восьмиричное значение nnn 
\0nnn - команды echo -e и printf %b - восьмиричное значение nnn 
\' - строка в форме  $'...' - одиночная кавычка
\" - строка в форме  $'...' - двойная кавычка
\? - строка в форме  $'...' - знак вопроса
\\ - все контексты - обратная косая черта

Благодаря заключению в кавычки отменяется специальное назначение символов и появляется возвожность использовать их буквально. Символы имеющие спец. назначения
1) ; - разделитель команд
2) & - выполенние команд в фоновом режиме
3) () - группирование команд
4) | - канал
5) <> & - знаки переадресации
6) * ? [] ~ + - @ ! - метасимволы подстановки имен
7) " ' \ - служат для заключения в кавычки других символов
8) ` - подстановка команд
9) $ - подстановка переменных (команд или арифметических выражений)
10) # - обозначает начало комментария
11) Знаки пробела, табуляции и новой строки - разделители строк

В кавычки могут быть заключены след. символы
1) "..." - Все, что заключено в открывающие и закрывающие скобки, за исключением перечисленных ниже символов, сохраняющихсвое спец. назначение
        $ - Подстановка (переменных, команд или арифметическая подстановка)
        ` - подстановка команд
        " - обозначает конец символьной строки, заключенной в двойные кавычки
2) '...' - Все, что заключено в открывающие и закрывающие одиночные кавычки, воспринимается буквально, за исключением другого знака одничной кавычки
3) \ - символ, следующий после знака \, воспринимается буквально. Для экранизирования знаков ", $ и ` их следует заключать в двойные кавычки "..."
4) $"..." - то же самое, что и "...", за исключением преобразования по языковому стандарту
5) $'...' - то же самое, что и '...', только текст в одиночных кавычках обрабатывается с учетом управляющих последовательностей символов

Формы команд
Ниже приведены различные формы команд, допустимые в оболочке Bash
1) cmd & - выполнить указанную команду cmd в фоновом режиме
2) { cmd1 ; cmd2 ; } - выполнить указанные команды группой в текущей оболочке
3) ( cmd1 ; cmd2 ; ) - вывполнить указанные команды группой в подоболочке
4) cmd1 | cmd2 - передать выход из команды cmd1 по каналу на вход в cmd2
5) cmd1 `cmd2` - произвести подстановку команд. В частност, использовать результат, выводимый из команды cmd2, в качестве аргумента команды cmd1
6) cmd1 $ (cmd2) - произвести подстановку команд по стандарту POSIX. Допускается вложение 
7) cmd $ ((выражение)) - провести арифметическую подстановку по стандарту POSIX. В частности, использовать числовой результат вычисления заданного выраженияв качестве аргумента указанной команды cmd
8) cmd1 && cmd2 - выполнить логическую операцию И. В частности, выполнить сначала указанную команду cmd1, а затем команду cmd2 при удачном исходе выполнения команды cmd1. Это "укороченная" форма логической операции, при которой cmd2 вообще не выполняется при неудачном исходе выполнения cmd1. 
9) cmd1 || cmd2 - выполнить логическую операцию ИЛИ. В частности, выполнить команду cmd1, а при неудачном исходе ее выполнения - команду cmd2. Это укороченная форма логической операции, при которой команда cmd2 вообще не выполняется при удачном исходе выполнения команды cmd1  
10) !cmd - Выполнить логическую операцию НЕ. В частности, выполнить указанную команду cmd и выдпть нулевой код завершения, если выполнение cmd завершится ненулевым кодом. В противном случае, ненуевой код завершения, если выполнение cmd завершится нулевым кодом.

Формы переадресации ввода-вывода
Простая переадресация ввода-вывода
cmd > файл - направить результат, выводимый из команды cmd, в заданный файл, фактически перезаписав его содержимое
cmd >> файл - направить результат, выводимый из указанной команды cmd, в заданный файл, присоединив его к содержимому данного файла
cmd < файл - взять исходные данные для команды cmd из заданного файла
cmd < текст - все содержимое сценария оболочки вплоть до строки, соответствует заданному тексту, становится стандартным вводом для команды cmd, причем заданный текст может храниться в переменной оболочке. Такую форму команд иногда называют встраиваемым документом, где входные данные вводятся с клавиатуры или из программы оболочки. Подобный синтаксис встречается в командах cat, ex, sed. Если же какая-то часть текста заключается в кавычки, входные данные передаются буквально. В  противном случае, обрабатывается содержимое, получаемое в результате подстановки переменных, команд и арифметических выражений.
cmd <<< слово - предоставить текст заданного слова вместе с завершающим знаком новой строки в качестве входных данных для команды cmd.
cmd <> файл - открыть заданный файл для чтения и записать в него результат выполнения команды cmd, направленный в стандартный вывод. Прежнее содержимое файла не нарушается.
cmd <| файл - направить результат, выводимый командой cm, в заданный файл, перезаписав его содержимое, даже если в оболочке установлен параметр noclobber.

Переадресация ввода-вывода с использованием дескрипторов файлов
cmd>&n - направить результат, выводимый командой cmd, в файл с заданным дескриптором n
cmd m>&n - то же, что и выше, за исключением того, что выводимый результат, обычно направленный в файл с заданным дескриптором m, фактически направляется в файл с дескриптором n
cmd>&- - закрыть стандартный вывод.
cmd<&n - взять входные данные для команды cmd из файла с заданным дескриптором n 
cmd m < &n - то же, что и выше, за исключением того, что входные данные, обычно поступающие из файла с дескриптором m, на этот раз поступают из файла с дескриптором n
cmd<&- - закрыть стандартный ввод.
cmd<&n- - направить содержимое файла с дескриптором n в стандартный ввод, получив сначала копию, а затем закрыв оригинал.   
cmd>&n- - направить содержимое файла с заданным дескриптором n в стандартный вывод, получив сначала копию, а затем закрыв оригинал. 

Многократная переадресация ввода-вывода
cmd 2> файл - направить стандартный вывод ошибок в заданный файл. При этом стнадартный вывод данных остается прежним (в частности он направляется на экран терминала)
cmd > файл 2>&1  - направить стнадартный вывод ошибок и данных в заданный файл.
cmd>&файл - то же, что и выше.
cmd&> файл - то же, что и выше, но более предпочтительная форма.
cmd & >> файл - присоеденить стнадартный вывод данных и ошибок к содержанию заданного файла.
cmd > файл1 2> файл2 - направить стандартный вывод данных в заданный файл1, а стандартный вывод ошибок в файл2 
cmd | tee файлы - направить результат, выводимый указанной командой cmd, как в стандартный вывод (как правило, на терминал), так и в заданные файлы
cmd 2>&1 | tee файлы - направить стандартный вывод данных и ошибок из команды cmd по каналу команде tee для переадресации как в стандартный вывод, так и в заданные файлы.
cmd | & tee файл - то же, что и выше.

Подстановка процессов
cmd<(команда) - выполнить заданную команду, соеденив ее выход с именованным каналом или файлом, открытым по пути \dev\fd, а также поместить имя файла в список аргументов команды cmd. Указаная команда cmd может прочитать сожержимое этого файла, чтобы обнаружить в нем результат, выводимый заданной командой.
cmd>(команда) - выполнить заданную команду, соеденив ее выход с именованным каналом или файлом, открытым по пути \dev\fd,  а также поместить имя файла в список аргументов команды cmd. Результат, выводимый указанной командой cmd в этот файл, служит в качестве входных данных для заданной команды.

Сохранение дескрипторов файлов переменных
В оболочке Bash допускается использовать форму {имя_переменной} вместо числового обозначения дескриптора файла при переадресации ввода-вывода. В подобных случаях оболочка выбирает в качетсве дескриптора файла числовое значение выше 9, присваивая его именованной переменной оболочки. Указанное имя_переменной может обозначать элементы массива и переменные, имеющие спец. назначение в оболочке. Подобная форма чаще всего применяется при переадресации ввода-вывода в команед exec. Благодаря этому дескриптор файла, сохраненный в переменной оболочки, может быть далее использован в сценарии.

Специальные имена файлов
При переадресации ввода-вывода в оболочкe Bash распознается несколько специальных имен файлов. Такие имена получают внутреннюю интерпритацию в оболочке Bash только в том случае, если они отсутствуют в самой системе. Специальные имена файлов:
/dev/stdin - дубликат дескриптора файла 0
/dev/stdout - дубликат дескриптора файла 1
/dev/stderr - дубликат дескриптора файла 2 
/dev/fd/<n> - дубликат дескриптора файла <n> 
/dev/tcp/<host>/<port> - оболочка Bash устанавливает соединение с указанным хостом (сетевым узлом), где <host> означает имя или IP-адрес хоста, чере заданный порт <port>, используя полученный в итоге дескриптор файла при переадресации ввода-вывода 
/dev/udp/<host>/<port> - оболочка Bash устанавливает соединение с указанным хостом (сетевым узлом), где <host> означает имя или IP-адрес хоста, чере заданный порт <port>, используя полученный в итоге дескриптор файла при переадресации ввода-вывода 

Функции
Функция в оболочке представляет собой совокупность команд, выполянемых в сценарии оболочки. Функции способствуют модульной организации программ оболочки, разделяя их на отдельные задачи. Благодаря этому код выполнения каждой задачи не повторяется всякий раз, когда требуется выполнить её.
            имя() {
              здесь следует код, образующий тело функции
                  } [виды переадресации]
             
Функции вызываются таким же образом, как и команды, встроенные в оболочку или внешние по отношению к ней. Для возврата кода завершения вызывающей части программы оболочки в функции может использоваться команда return.
            fucnction имя [()] {тело функции} [виды переадресации]
Функции разделяют общие с "родительской" оболочкой прерывания. Типы прерывания описаны ниже:
прерывание по сигналу - остается общим до тех пор, пока не будет переопределено в самой функции
DEBUG - является необщим, если только не активизирован режим трассировки функции. Если этот режим мне активизирован, перрывание DEBUG, формируемое при вызове функции, остается на месте после возврата из функции.
ERR - является необщим, если только не активизирован режим трассировки ошибок
EXIT - остается общим до тех пор, пока не будет переопределно в самой функции
RETURN -  является необщим, если только не активизирован режим трассировки функций

Функции могут иметь локальные переменные и могут быть рекурсивными. 
В оболочке Bash применяется модель соблюдения динамических областей видимости, где переменные, объявляенные как локальные, доступны не только в теле функции, но и в других функциях, которые её вызывают.
Не пользоваться командой exit в теле функции.
